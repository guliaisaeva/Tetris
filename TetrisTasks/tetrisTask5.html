<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris Task</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        text-decoration: none;
        list-style: none;
      }

      body {
        width: 100vw;
        height: 100vh;
        background-color: black;
      }
      .btn {
        width: 100%;
        text-align: center;
      }
      .btn button {
        padding: 8px 10px;
        border: none;
        border-radius: 10px;
        color: white;
      }
      #start {
        background: green;
      }
      #pause {
        background: red;
      }
      .main {
        width: 320px;
        height: 620px;
        margin: 100px auto 0;
        border: 10px solid silver;
        font-size: 0;
      }
      .cell {
        width: 30px;
        height: 30px;
        border: 1px solid silver;
        display: inline-block;
      }
      .movingCell {
        background-color: blue;
      }
      .fixedCell {
        background-color: green;
      }
    </style>
  </head>
  <body>
    <div class="btn">
      <button onclick="startGame()" id="start" class="button">Start</button>
      <button id="pause" class="button">Pause</button>
    </div>
    <div class="main"></div>

    <script>
      const main = document.querySelector(".main");

      const playfield = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      ];

      const gameSpeed = 400;
      function getRandomColor() {
        let color = ["green", "red", "pink", "yellow", "blue"];
        let randomColor = Math.floor(Math.random() * color.length);
        let newColor = color[randomColor];
      }

      let activeTetro = {
        x: 3,
        y: 0,
        shape: [
          [1, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
        ],
      };

      //function drawField dy cells inside of main area
      function drawField() {
        let mainInnerHtml = "";

        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              mainInnerHtml += `<div  class ="cell movingCell"></div>`;
            } else if (playfield[y][x] === 2) {
              mainInnerHtml += `<div class ="cell fixedCell"></div>`;
            } else {
              mainInnerHtml += `<div  class ="cell"></div>`;
            }
          }
        }
        main.innerHTML = mainInnerHtml;
      }
      const squere = document.querySelectorAll(".movingCell");
      console.log(squere);
      // remove after tetro moving old tetro position
      function removePrevActiveTetro() {
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              playfield[y][x] = 0;
            }
          }
        }
      }
      // updating active tetro
      function addActiveTetro() {
        removePrevActiveTetro();
        for (let y = 0; y < activeTetro.shape.length; y++) {
          for (let x = 0; x < activeTetro.shape[y].length; x++) {
            if (activeTetro.shape[y][x] === 1) {
              playfield[activeTetro.y + y][activeTetro.x + x] =
                activeTetro.shape[y][x];
            }
          }
        }
      }

      // function to rotate shapes (Tetro)
      function rotateTetro() {
        const prevTetroState = activeTetro.shape;
        activeTetro.shape = activeTetro.shape[0].map((val, index) =>
          activeTetro.shape.map((row) => row[index]).reverse()
        );

        if (hasCollisions()) {
          activeTetro.shape = prevTetroState;
        }
      }
      rotateTetro();

      // control if tetromino has collision
      function hasCollisions() {
        for (let y = 0; y < activeTetro.shape.length; y++) {
          for (let x = 0; x < activeTetro.shape[y].length; x++) {
            if (
              activeTetro.shape[y][x] &&
              (playfield[activeTetro.y + y] === undefined ||
                playfield[activeTetro.y + y][activeTetro.x + x] === undefined ||
                playfield[activeTetro.y + y][activeTetro.x + x] === 2)
            ) {
              return true;
            }
          }
        }
        return false;
      }
      // control if tetromino is at the end of area or has place to move
      function canTetroMoveDown() {
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              if (y === playfield.length - 1 || playfield[y + 1][x] === 2) {
                return false;
              }
            }
          }
        }
        return true;
      }

      // function moveTo Down() let tetrominos move to down
      function moveToDown() {
        if (canTetroMoveDown()) {
          for (let y = playfield.length - 1; y >= 0; y--) {
            for (let x = 0; x < playfield[y].length; x++) {
              if (playfield[y][x] === 1) {
                playfield[y + 1][x] = 1;
                playfield[y][x] = 0;
              }
            }
          }
        } else {
          fixedTetro();
        }
      }

      // // function moving tetro to left
      function canTetroMoveLeft() {
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              if (x === 0 || playfield[y][x - 1] === 2) {
                return false;
              }
            }
          }
        }
        return true;
      }

      function moveToLeft() {
        if (canTetroMoveLeft()) {
          for (let y = playfield.length - 1; y >= 0; y--) {
            for (let x = 0; x < playfield[y].length; x++) {
              if (playfield[y][x] === 1) {
                playfield[y][x - 1] = 1;
                playfield[y][x] = 0;
              }
            }
          }
        }
      }

      // function moving tetro to right
      function canTetroMoveRight() {
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              if (y === 9 || playfield[y][x + 1] === 2) {
                return false;
              }
            }
          }
        }
        return true;
      }

      function moveToRight() {
        if (canTetroMoveRight()) {
          for (let y = playfield.length - 1; y >= 0; y--) {
            for (let x = 9; x >= 0; x--) {
              if (playfield[y][x] === 1) {
                playfield[y][x + 1] = 1;
                playfield[y][x] = 0;
              }
            }
          }
        }
      }
      // control lines if they are filled or not
      function removeFullLines() {
        let canRemoveLine = true;
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] !== 2) {
              canRemoveLine = false;
              break;
            }
          }
          if (canRemoveLine) {
            playfield.splice(y, 1);
            playfield.splice(0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
          }
          canRemoveLine = true;
        }
      }
      // function fixedTetro
      function fixedTetro() {
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              playfield[y][x] = 2;
            }
          }
        }
      }
      function moveTetroDown() {
        activeTetro.y += 1;
        if (hasCollisions()) {
          activeTetro.y -= 1;
          fixedTetro();
          activeTetro.y = 0;
        }
      }

      document.onkeydown = function (e) {
        e.preventDefault();
        console.log(e.keyCode);
        if (e.keyCode === 37) {
          //to left
          activeTetro.x -= 1;
          if (hasCollisions()) {
            activeTetro.x += 1;
          }
        } else if (e.keyCode === 39) {
          //to right
          activeTetro.x += 1;
          if (hasCollisions()) {
            activeTetro.x -= 1;
          }
        } else if (e.keyCode === 40) {
          // speed up to down
          activeTetro.y += 1;
          if (hasCollisions()) {
            activeTetro.y -= 1;
            fixedTetro();
            activeTetro.y = 0;
          }
        } else if (e.keyCode === 38) {
          //to up  rotate
          rotateTetro();
        }
        addActiveTetro();
        drawField();
      };
      addActiveTetro();
      drawField();

      // function for starting to move down

      function startGame() {
        moveTetroDown();
        moveToDown();
        drawField();
        setTimeout(startGame, gameSpeed);
      }
      let setTiming = setTimeout(startGame, gameSpeed);
      clearTimeout(setTiming);
    </script>
  </body>
</html>

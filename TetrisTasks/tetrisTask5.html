<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris Task</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        text-decoration: none;
        list-style: none;
      }

      body {
        width: 100vw;
        height: 100vh;
        background-color: black;
        color: white;
        font-family: Arial, Helvetica, sans-serif;
      }
      .btn {
        width: 100%;
        text-align: center;
      }
      .btn button {
        padding: 8px 10px;
        border: none;
        border-radius: 10px;
        color: white;
      }
      #start {
        background: green;
      }
      #pause {
        background: red;
      }
      .main {
        width: 320px;
        height: 620px;
        margin: 40px auto 0;
        border: 10px solid silver;
        font-size: 0;
      }
      .cell {
        width: 30px;
        height: 30px;
        border: 1px solid silver;
        display: inline-block;
      }
      .movingCell {
        background-color: blue;
      }
      .fixedCell {
        background-color: green;
      }
      .game {
        width: 320px;
        margin: auto;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <div class="game">
      <div>Level: <span id="level">0</span></div>
      <div>Score: <span id="score">0</span></div>

      <div class="btn">
        <button id="start" class="button">Start</button>
        <button id="pause" class="button">Pause</button>
      </div>
      <div class="main"></div>
    </div>

    <script>
      const main = document.querySelector(".main");
      const scoreEl = document.getElementById("score");
      const levelEl = document.getElementById("level");
      const currentlevel = 1;
      let possibleLevel = {
        1: { scorePerLine: 10, speed: 400, nextLevelScore: 100 },
        2: { scorePerLine: 15, speed: 300, nextLevelScore: 200 },
        3: { scorePerLine: 20, speed: 200, nextLevelScore: 300 },
        4: { scorePerLine: 25, speed: 100, nextLevelScore: 400 },
        5: { scorePerLine: 30, speed: 50, nextLevelScore: Infinity },
      };

      const playfield = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      ];

      let score = 0;
      // function getRandomColor() {
      //   let color = ["green", "red", "pink", "yellow", "blue"];
      //   let randomColor = Math.floor(Math.random() * color.length);
      //   let newColor = color[randomColor];
      // }

      let activeTetro = {
        x: 0,
        y: 0,
        shape: [
          [1, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
        ],
      };
      let figures = {
        O: [
          [1, 1],
          [1, 1],
        ],
        I: [
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 0],
        ],
        S: [
          [0, 1, 1],
          [1, 1, 0],
          [0, 0, 0],
        ],
        Z: [
          [1, 1, 0],
          [0, 1, 1],
          [0, 0, 0],
        ],
        L: [
          [1, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
        ],
        J: [
          [0, 0, 1],
          [0, 0, 1],
          [0, 1, 1],
        ],
        T: [
          [1, 1, 1],
          [0, 1, 0],
          [0, 0, 0],
        ],
      };
      //function drawField dy cells inside of main area
      function drawField() {
        let mainInnerHtml = "";

        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              mainInnerHtml += `<div  class ="cell movingCell"></div>`;
            } else if (playfield[y][x] === 2) {
              mainInnerHtml += `<div class ="cell fixedCell"></div>`;
            } else {
              mainInnerHtml += `<div  class ="cell"></div>`;
            }
          }
        }
        main.innerHTML = mainInnerHtml;
      }

      // remove after tetro moving old tetro position
      function removePrevActiveTetro() {
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              playfield[y][x] = 0;
            }
          }
        }
      }
      // updating active tetro
      function addActiveTetro() {
        removePrevActiveTetro();
        for (let y = 0; y < activeTetro.shape.length; y++) {
          for (let x = 0; x < activeTetro.shape[y].length; x++) {
            if (activeTetro.shape[y][x] === 1) {
              playfield[activeTetro.y + y][activeTetro.x + x] =
                activeTetro.shape[y][x];
            }
          }
        }
      }

      // function to rotate shapes (Tetro)
      function rotateTetro() {
        const prevTetroState = activeTetro.shape;
        activeTetro.shape = activeTetro.shape[0].map((val, index) =>
          activeTetro.shape.map((row) => row[index]).reverse()
        );

        if (hasCollisions()) {
          activeTetro.shape = prevTetroState;
        }
      }
      // rotateTetro();

      // control if tetromino has collision
      function hasCollisions() {
        for (let y = 0; y < activeTetro.shape.length; y++) {
          for (let x = 0; x < activeTetro.shape[y].length; x++) {
            if (
              activeTetro.shape[y][x] &&
              (playfield[activeTetro.y + y] === undefined ||
                playfield[activeTetro.y + y][activeTetro.x + x] === undefined ||
                playfield[activeTetro.y + y][activeTetro.x + x] === 2)
            ) {
              return true;
            }
          }
        }
        return false;
      }

      // control lines if they are filled or not
      function removeFullLines() {
        let canRemoveLine = true;
        filledlines = 0;
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] !== 2) {
              canRemoveLine = false;
              break;
            }
          }
          if (canRemoveLine) {
            playfield.splice(y, 1);
            playfield.splice(0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
            filledlines += 1;
          }
          canRemoveLine = true;
        }
        switch (filledlines) {
          case 1:
            score += 10;
            break;
          case 2:
            score += 10 * 3;
            break;
          case 3:
            score += 10 * 6;
            break;
          case 4:
            score += 10 * 12;
            break;
        }

        scoreEl.innerHTML = score;
        if (score >= possibleLevel[currentlevel].nextLevelScore) {
          currentlevel++;
          levelEl.innerHTML = currentlevel;
        }
      }

      // function to get new shape or tetromino
      function getNewTetro() {
        const possibleFigure = "OILJTSZ";
        const randomFigure = Math.floor(Math.random() * 7);
        return figures[possibleFigure[randomFigure]];
      }

      // function fixedTetro
      function fixedTetro() {
        for (let y = 0; y < playfield.length; y++) {
          for (let x = 0; x < playfield[y].length; x++) {
            if (playfield[y][x] === 1) {
              playfield[y][x] = 2;
            }
          }
        }
      }

      // function to move shape to down
      function moveTetroDown() {
        activeTetro.y += 1;
        if (hasCollisions()) {
          activeTetro.y -= 1;
          fixedTetro();
          removeFullLines();
          activeTetro.shape = getNewTetro();
          activeTetro.x = Math.floor((10 - activeTetro.shape[0].length) / 2);
          activeTetro.y = 0;
        }
      }

      // // control if tetromino is at the end of area or has place to move
      // function canTetroMoveDown() {
      //   for (let y = 0; y < playfield.length; y++) {
      //     for (let x = 0; x < playfield[y].length; x++) {
      //       if (playfield[y][x] === 1) {
      //         if (y === playfield.length - 1 || playfield[y + 1][x] === 2) {
      //           return false;
      //         }
      //       }
      //     }
      //   }
      //   return true;
      // }

      // // function moveTo Down() let tetrominos move to down
      // function moveToDown() {
      //   if (canTetroMoveDown()) {
      //     for (let y = playfield.length - 1; y >= 0; y--) {
      //       for (let x = 0; x < playfield[y].length; x++) {
      //         if (playfield[y][x] === 1) {
      //           playfield[y + 1][x] = 1;
      //           playfield[y][x] = 0;
      //         }
      //       }
      //     }
      //   } else {
      //     fixedTetro();
      //   }
      // }

      // // // function moving tetro to left
      // function canTetroMoveLeft() {
      //   for (let y = 0; y < playfield.length; y++) {
      //     for (let x = 0; x < playfield[y].length; x++) {
      //       if (playfield[y][x] === 1) {
      //         if (x === 0 || playfield[y][x - 1] === 2) {
      //           return false;
      //         }
      //       }
      //     }
      //   }
      //   return true;
      // }

      // function moveToLeft() {
      //   if (canTetroMoveLeft()) {
      //     for (let y = playfield.length - 1; y >= 0; y--) {
      //       for (let x = 0; x < playfield[y].length; x++) {
      //         if (playfield[y][x] === 1) {
      //           playfield[y][x - 1] = 1;
      //           playfield[y][x] = 0;
      //         }
      //       }
      //     }
      //   }
      // }

      // // function moving tetro to right
      // function canTetroMoveRight() {
      //   for (let y = 0; y < playfield.length; y++) {
      //     for (let x = 0; x < playfield[y].length; x++) {
      //       if (playfield[y][x] === 1) {
      //         if (y === 9 || playfield[y][x + 1] === 2) {
      //           return false;
      //         }
      //       }
      //     }
      //   }
      //   return true;
      // }

      // function moveToRight() {
      //   if (canTetroMoveRight()) {
      //     for (let y = playfield.length - 1; y >= 0; y--) {
      //       for (let x = 9; x >= 0; x--) {
      //         if (playfield[y][x] === 1) {
      //           playfield[y][x + 1] = 1;
      //           playfield[y][x] = 0;
      //         }
      //       }
      //     }
      //   }
      // }

      document.onkeydown = function (e) {
        e.preventDefault();
        console.log(e.keyCode);
        if (e.keyCode === 37) {
          //to left
          activeTetro.x -= 1;
          if (hasCollisions()) {
            activeTetro.x += 1;
          }
        } else if (e.keyCode === 39) {
          //to right
          activeTetro.x += 1;
          if (hasCollisions()) {
            activeTetro.x -= 1;
          }
        } else if (e.keyCode === 40) {
          // speed up to down
          moveTetroDown();
        } else if (e.keyCode === 38) {
          //to up  rotate
          rotateTetro();
        }
        addActiveTetro();
        drawField();
      };

      scoreEl.innerHTML = score;
      levelEl.innerHTML = currentlevel;
      addActiveTetro();
      drawField();

      // function for starting to move down

      function startGame() {
        moveTetroDown();
        addActiveTetro();
        drawField();
        setTimeout(startGame, possibleLevel[currentlevel].speed);
      }

      setTimeout(startGame, possibleLevel[currentlevel].speed);
    </script>
  </body>
</html>
